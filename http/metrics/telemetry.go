package metrics

import (
	"errors"
	"os"
	"sync"
	"time"

	"github.com/gofiber/fiber/v2/log"
	"github.com/prometheus/client_golang/prometheus"
	"github.com/prometheus/client_golang/prometheus/push"
	dto "github.com/prometheus/client_model/go"
	"go.uber.org/zap"
)

const (
	metricsPushInterval = time.Second * 60
)

type (
	TelemetryInput struct {
		NodeName string
	}
	Telemetry struct {
		nodeName                string
		pushGatewayAddress      string
		wastedTimeMutex         sync.Mutex
		wastedTimeCounter       prometheus.Counter
		secretsGeneratedMutex   sync.Mutex
		secretsGeneratedCounter prometheus.Counter
		shutdownChan            chan bool
	}
)

func NewTelemetry(input *TelemetryInput) (*Telemetry, error) {
	if os.Getenv("PUSH_GATEWAY_ADDRESS") == "" {
		return nil, errors.New("PUSH_GATEWAY_ADDRESS not set")
	}

	return &Telemetry{
		nodeName:           input.NodeName,
		pushGatewayAddress: os.Getenv("PUSH_GATEWAY_ADDRESS"),
		wastedTimeCounter: prometheus.NewCounter(prometheus.CounterOpts{
			Name: "time_wasted",
			Help: "Time wasted by clients calling this service",
		}),
		secretsGeneratedCounter: prometheus.NewCounter(prometheus.CounterOpts{
			Name: "secrets_generated",
			Help: "Number of secrets generated by this service",
		}),
		wastedTimeMutex:       sync.Mutex{},
		secretsGeneratedMutex: sync.Mutex{},
	}, nil
}

func (t *Telemetry) Start() {
	registry := prometheus.NewRegistry()
	registry.MustRegister(t.wastedTimeCounter)
	registry.MustRegister(t.secretsGeneratedCounter)

	go func() {
		ticker := time.Tick(metricsPushInterval)
		for {
			select {
			case <-t.shutdownChan:
				return
			case <-ticker:
				if err := push.New(t.pushGatewayAddress, t.nodeName).Gatherer(registry).Push(); err != nil {
					zap.L().Sugar().Errorw("Failed to push metrics", "error", err)
				}
			}
		}
	}()
}

func (t *Telemetry) Stop() {
	zap.L().Sugar().Warnw("Stopping telemetry")
	t.shutdownChan <- true

	if err := push.New(t.pushGatewayAddress, t.nodeName).Delete(); err != nil {
		zap.L().Sugar().Errorw("Failed to delete metrics", "error", err)
		return
	}

	zap.L().Sugar().Warnw("Stopped telemetry")
}

func (t *Telemetry) TrackWastedTime(wastedTime time.Duration) {
	t.wastedTimeMutex.Lock()
	defer t.wastedTimeMutex.Unlock()
	t.wastedTimeCounter.Add(wastedTime.Seconds())
}

func (t *Telemetry) GetWastedTime() float64 {
	return getCounterValue(t.wastedTimeCounter)
}

func (t *Telemetry) TrackGeneratedSecrets(generatedSecrets int) {
	t.secretsGeneratedMutex.Lock()
	defer t.secretsGeneratedMutex.Unlock()
	t.secretsGeneratedCounter.Add(float64(generatedSecrets))
}

func getCounterValue(counter prometheus.Counter) float64 {
	m := &dto.Metric{}
	if err := counter.Write(m); err != nil {
		log.Warn("Failed to pull metric data", "error", err)
		return 0
	}
	return m.GetCounter().GetValue()
}
